# Script-Based Testing Framework - Critical Amendments

**Version**: 2.0.1  
**Amendment Date**: September 30, 2025  
**Status**: Design Amendment - Ready for Review

---

## Amendment Summary

This document addresses three critical design decisions that must be resolved before implementation:

1. **Universal Test Command Support**: Handling ANY testing task/command generated by agents
2. **Technical Debt Management**: Who generates debt items and how they integrate with SDLC
3. **Task Status Authority**: Who controls task completion status to prevent agent gaming

---

## AMENDMENT 1: Universal Test Command Support

### Problem Statement

The agent can generate ANY type of testing task during `/tasks` generation:
- Unit tests (Jest, pytest, Mocha, JUnit)
- Integration tests (API tests, database tests)
- E2E tests (Cypress, Playwright, Selenium)
- Performance tests (k6, JMeter)
- Security tests (OWASP ZAP, Bandit)
- Custom shell scripts
- Docker commands
- Database queries
- External service calls

**Current Spec Limitation**: Only handles Jest + MCP browser automation.

### Solution: Extensible Action Type System

**Principle**: The script-execution-engine must support ANY executable command without code changes.

#### 1.1 Enhanced Action Type Registry

Modify the JSON schema to support extensible action types:

```json
{
  "executionEngine": {
    "actionTypes": {
      "TERMINAL_COMMAND": {
        "executor": "run_in_terminal",
        "requiredParams": ["command", "workingDirectory"],
        "optionalParams": ["environment", "timeout", "expectedExitCodes"],
        "evidenceCapture": {
          "stdout": true,
          "stderr": true,
          "exitCode": true,
          "duration": true,
          "environmentSnapshot": false
        }
      },
      
      "MCP_BROWSER_COMMAND": {
        "executor": "mcp_tool_call",
        "requiredParams": ["action", "parameters"],
        "optionalParams": ["timeout", "retryAttempts"],
        "evidenceCapture": {
          "request": true,
          "response": true,
          "screenshots": true,
          "domSnapshot": true
        }
      },

      "DOCKER_COMMAND": {
        "executor": "docker_client",
        "requiredParams": ["dockerCommand", "containerOrImage"],
        "optionalParams": ["volumes", "ports", "environment"],
        "evidenceCapture": {
          "containerLogs": true,
          "inspectOutput": true,
          "exitCode": true
        }
      },

      "DATABASE_QUERY": {
        "executor": "database_client",
        "requiredParams": ["connectionString", "query"],
        "optionalParams": ["queryTimeout", "transactionMode"],
        "evidenceCapture": {
          "queryResult": true,
          "rowCount": true,
          "executionPlan": true,
          "duration": true
        }
      },

      "HTTP_REQUEST": {
        "executor": "http_client",
        "requiredParams": ["url", "method"],
        "optionalParams": ["headers", "body", "timeout"],
        "evidenceCapture": {
          "requestHeaders": true,
          "requestBody": true,
          "responseStatus": true,
          "responseHeaders": true,
          "responseBody": true,
          "duration": true
        }
      },

      "CUSTOM_SCRIPT": {
        "executor": "script_runner",
        "requiredParams": ["scriptPath", "interpreter"],
        "optionalParams": ["arguments", "environment", "timeout"],
        "evidenceCapture": {
          "scriptContent": true,
          "stdout": true,
          "stderr": true,
          "exitCode": true
        }
      },

      "FILE_VALIDATION": {
        "executor": "file_validator",
        "requiredParams": ["filePath", "validationType"],
        "optionalParams": ["expectedContent", "schema"],
        "evidenceCapture": {
          "fileExists": true,
          "fileSize": true,
          "fileHash": true,
          "validationResult": true
        }
      }
    }
  }
}
```

#### 1.2 Generic Executor Interface

**File**: `.specify/tools/executors/base-executor.js`

```javascript
/**
 * Base class for all test executors
 * Ensures consistent evidence collection across all action types
 */
class BaseExecutor {
  constructor(config) {
    this.config = config;
    this.evidenceCollector = new EvidenceCollector();
  }

  /**
   * Execute action and collect evidence
   * @param {Object} action - Action definition from test plan
   * @param {String} taskId - Task identifier
   * @param {String} stepId - Step identifier
   * @returns {Promise<ExecutionResult>}
   */
  async execute(action, taskId, stepId) {
    const startTime = new Date();
    
    try {
      // Validate action parameters
      this.validateParameters(action);
      
      // Pre-execution evidence
      const preEvidence = await this.collectPreExecutionEvidence(action);
      
      // Execute the actual action
      const result = await this.executeAction(action);
      
      // Post-execution evidence
      const postEvidence = await this.collectPostExecutionEvidence(action, result);
      
      // Combine evidence with authenticity markers
      const evidence = this.assembleEvidence({
        preEvidence,
        result,
        postEvidence,
        startTime,
        endTime: new Date(),
        taskId,
        stepId,
        actionType: this.constructor.name
      });
      
      // Save evidence
      await this.saveEvidence(evidence, taskId, stepId);
      
      return {
        success: this.determineSuccess(result),
        evidence: evidence,
        result: result
      };
      
    } catch (error) {
      // Collect error evidence
      const errorEvidence = await this.collectErrorEvidence(error, action);
      
      return {
        success: false,
        error: error.message,
        evidence: errorEvidence
      };
    }
  }

  /**
   * Each executor implements this method
   * @abstract
   */
  async executeAction(action) {
    throw new Error('executeAction must be implemented by subclass');
  }

  /**
   * Validate required parameters
   */
  validateParameters(action) {
    const required = this.config.requiredParams || [];
    const missing = required.filter(param => !action.parameters[param]);
    
    if (missing.length > 0) {
      throw new Error(`Missing required parameters: ${missing.join(', ')}`);
    }
  }

  /**
   * Collect evidence before execution
   */
  async collectPreExecutionEvidence(action) {
    return {
      timestamp: new Date().toISOString(),
      actionType: action.type,
      parameters: action.parameters,
      environment: process.env.NODE_ENV,
      workingDirectory: process.cwd()
    };
  }

  /**
   * Collect evidence after execution
   */
  async collectPostExecutionEvidence(action, result) {
    return {
      timestamp: new Date().toISOString(),
      success: this.determineSuccess(result),
      duration: result.duration || 0
    };
  }

  /**
   * Assemble complete evidence package
   */
  assembleEvidence(components) {
    return {
      ...components,
      authenticity: {
        generatedBy: 'CODOR Script Execution Engine v2.0',
        executor: this.constructor.name,
        timestamp: new Date().toISOString(),
        platform: process.platform,
        nodeVersion: process.version,
        processId: process.pid,
        authentic: true,
        agentInvolved: false
      }
    };
  }

  /**
   * Save evidence to file system
   */
  async saveEvidence(evidence, taskId, stepId) {
    const evidencePath = path.join(
      this.config.evidenceBaseDirectory,
      taskId,
      stepId,
      `${this.constructor.name.toLowerCase()}-evidence.json`
    );
    
    await fs.promises.mkdir(path.dirname(evidencePath), { recursive: true });
    await fs.promises.writeFile(
      evidencePath,
      JSON.stringify(evidence, null, 2)
    );
    
    return evidencePath;
  }

  /**
   * Determine if execution was successful
   */
  determineSuccess(result) {
    // Default: check exit code or success flag
    if (result.exitCode !== undefined) {
      return result.exitCode === 0;
    }
    if (result.success !== undefined) {
      return result.success;
    }
    return true; // Assume success if no failure indicators
  }
}

module.exports = BaseExecutor;
```

#### 1.3 Specific Executor Implementations

**Example: Docker Executor**

**File**: `.specify/tools/executors/docker-executor.js`

```javascript
const BaseExecutor = require('./base-executor');
const { spawn } = require('child_process');

class DockerExecutor extends BaseExecutor {
  async executeAction(action) {
    const { dockerCommand, containerOrImage, volumes, ports, environment } = action.parameters;
    
    // Build docker command
    const args = this.buildDockerArgs(dockerCommand, containerOrImage, {
      volumes,
      ports,
      environment
    });
    
    // Execute docker command
    return new Promise((resolve, reject) => {
      const process = spawn('docker', args, {
        stdio: ['pipe', 'pipe', 'pipe']
      });
      
      let stdout = '';
      let stderr = '';
      
      process.stdout.on('data', data => { stdout += data.toString(); });
      process.stderr.on('data', data => { stderr += data.toString(); });
      
      process.on('close', exitCode => {
        resolve({
          exitCode,
          stdout,
          stderr,
          duration: Date.now() - startTime
        });
      });
      
      process.on('error', reject);
    });
  }

  buildDockerArgs(command, target, options) {
    const args = [command, target];
    
    if (options.volumes) {
      options.volumes.forEach(v => args.push('-v', v));
    }
    
    if (options.ports) {
      options.ports.forEach(p => args.push('-p', p));
    }
    
    if (options.environment) {
      Object.entries(options.environment).forEach(([key, value]) => {
        args.push('-e', `${key}=${value}`);
      });
    }
    
    return args;
  }

  async collectPostExecutionEvidence(action, result) {
    const baseEvidence = await super.collectPostExecutionEvidence(action, result);
    
    // Add Docker-specific evidence
    if (action.parameters.containerOrImage) {
      try {
        // Collect container logs if it was a run command
        const containerLogs = await this.getContainerLogs(action.parameters.containerOrImage);
        baseEvidence.containerLogs = containerLogs;
        
        // Get container inspect output
        const inspectOutput = await this.inspectContainer(action.parameters.containerOrImage);
        baseEvidence.inspectOutput = inspectOutput;
        
      } catch (error) {
        baseEvidence.dockerEvidenceError = error.message;
      }
    }
    
    return baseEvidence;
  }
}

module.exports = DockerExecutor;
```

#### 1.4 Agent Test Specification Guidelines

Add to test specification generation guidance in `/tasks` command:

```markdown
## Test Command Specification Guidelines

When generating test specifications, you MUST follow these rules:

### 1. Use Appropriate Action Type

Match your test command to the correct action type:

- **JavaScript/TypeScript tests**: Use `TERMINAL_COMMAND` with `npm test`, `jest`, `mocha`
- **Python tests**: Use `TERMINAL_COMMAND` with `pytest`, `python -m unittest`
- **Browser automation**: Use `MCP_BROWSER_COMMAND` with MCP tools
- **Docker tests**: Use `DOCKER_COMMAND` for container-based tests
- **Database tests**: Use `DATABASE_QUERY` for SQL/NoSQL validation
- **API tests**: Use `HTTP_REQUEST` for REST/GraphQL endpoints
- **Custom scripts**: Use `CUSTOM_SCRIPT` for bash/powershell scripts

### 2. Provide Complete Parameters

For `TERMINAL_COMMAND`:
```json
{
  "type": "TERMINAL_COMMAND",
  "parameters": {
    "command": "npm test -- __tests__/contracts/endpoint.test.ts",
    "workingDirectory": "/absolute/path/to/package",
    "environment": { "NODE_ENV": "test" },
    "timeout": 30000,
    "expectedExitCodes": [0]
  }
}
```

For `HTTP_REQUEST`:
```json
{
  "type": "HTTP_REQUEST",
  "parameters": {
    "url": "http://localhost:3000/api/endpoint",
    "method": "POST",
    "headers": { "Content-Type": "application/json" },
    "body": { "test": "data" },
    "timeout": 5000
  }
}
```

### 3. Specify Evidence Requirements

Define what evidence must be captured:

```json
{
  "evidenceCapture": {
    "stdout": true,
    "stderr": true,
    "exitCode": true,
    "duration": true,
    "responseBody": true,
    "screenshots": false
  }
}
```

### 4. Provide Success Criteria

Define how to determine success:

```json
{
  "successCriteria": {
    "exitCode": 0,
    "stdoutContains": "All tests passed",
    "responseStatus": 200,
    "maxDuration": 5000
  }
}
```
```

**Result**: Script-execution-engine can handle ANY test command the agent generates, without code changes.

---

## AMENDMENT 2: Technical Debt Management Authority

### Problem Statement

Who generates technical debt items and how do they integrate with SDLC?

**Options**:
1. **Script generates debt directly** → 100% trustworthy but requires complex logic
2. **Script generates debt data, agent formats** → Simple task, low fabrication risk
3. **Hybrid: Script decides routing, agent writes files** → Balance of control

### Solution: Script-Generated Structured Debt + Agent Formatting (Option 2 Enhanced)

**Principle**: Script makes ALL decisions and generates complete data. Agent performs ONLY mechanical file writing with zero interpretation.

#### 2.1 Script-Generated Debt Structure

**File**: `evidence/[TASK_ID]/technical-debt-data.json`

This file is 100% generated by the script with NO agent involvement:

```json
{
  "taskId": "T005",
  "testExecutionId": "exec-2025-09-30-1030",
  "generatedAt": "2025-09-30T10:35:00.000Z",
  "generatedBy": "CODOR Script Execution Engine v2.0",
  "agentInvolved": false,
  
  "debtItems": [
    {
      "debtId": "DEBT-T005-001",
      "title": "API Endpoint Missing: POST /api/quotes",
      "description": "Contract tests failing because POST /api/quotes endpoint not implemented. Endpoint returns 404 instead of accepting quote creation requests.",
      
      "classification": {
        "category": "API_ENDPOINT_MISSING",
        "severity": "CRITICAL",
        "priority": 1,
        "estimatedEffort": "6-8 hours"
      },
      
      "routing": {
        "destination": "SPRINT_TASKS",
        "reason": "CRITICAL severity always routes to sprint",
        "sprintTaskId": "T031",
        "inventoryCorrelationId": "DEBT-INV-2025-09-30-001"
      },
      
      "testFailure": {
        "testFile": "__tests__/contracts/quotes-post.test.ts",
        "testName": "should return 201 Created with proper JSON structure for valid quote",
        "errorMessage": "Error: connect ECONNREFUSED 127.0.0.1:3000",
        "errorStack": "...",
        "expectedBehavior": "POST /api/quotes returns 201 with created quote object",
        "actualBehavior": "Connection refused - endpoint doesn't exist"
      },
      
      "evidence": {
        "files": [
          "evidence/T005/contract-test-execution.log",
          "evidence/T005/T005.1/mcp-raw-outputs/evaluate.json"
        ],
        "relevantLogLines": [145, 156, 178],
        "screenshots": []
      },
      
      "implementationGuidance": {
        "files": [
          "packages/web/src/pages/api/v1/quotes.ts"
        ],
        "steps": [
          "Create POST /api/v1/quotes route handler",
          "Implement request validation using Zod schemas (see T001)",
          "Add quote creation service logic (see T002)",
          "Implement business logic for quote calculations (subtotal, tax, total)",
          "Add error handling and appropriate HTTP status codes (201, 400, 500)"
        ],
        "dependencies": [
          "T001: Quote schema validation must be complete",
          "T002: Quote service layer must exist"
        ],
        "acceptanceCriteria": [
          "POST /api/quotes returns 201 with valid quote object",
          "Invalid requests return 400 with Zod validation errors",
          "Quote calculations are accurate (subtotal, tax, total)",
          "All 15 contract tests pass"
        ]
      },
      
      "agentInstructions": {
        "markdownFormat": "Use this exact structure in technical-debt.md",
        "taskFileUpdate": "Add to tasks.md as new task T031 under Phase 2",
        "inventoryUpdate": "Add to debt-inventory.md with correlation ID DEBT-INV-2025-09-30-001",
        "prohibitedActions": [
          "DO NOT modify severity, priority, or routing decisions",
          "DO NOT mark this debt as complete",
          "DO NOT skip inventory correlation"
        ]
      }
    }
  ],
  
  "routingSummary": {
    "totalDebtItems": 3,
    "routedToSprint": 2,
    "routedToInventory": 1,
    "sprintCapacity": {
      "currentTasks": 30,
      "maxTasks": 35,
      "availableSlots": 5,
      "criticalHighTasks": 12,
      "maxCriticalHigh": 15
    }
  },
  
  "authenticity": {
    "sha256Hash": "abc123...",
    "signatureVerification": "valid",
    "tamperDetection": "none"
  }
}
```

#### 2.2 Agent Mechanical File Writing

The agent performs ONLY these mechanical operations:

**Operation 1: Update tasks.md**

```markdown
## Phase 2: Test-First Development (TDD)

[...existing tasks...]

- [ ] **T031**: [GENERATED FROM DEBT-T005-001] Implement POST /api/quotes endpoint
  - Priority: CRITICAL
  - Estimated Effort: 6-8 hours
  - Debt Source: DEBT-T005-001
  - Evidence: evidence/T005/contract-test-execution.log
  - Acceptance Criteria: All 15 contract tests pass
  - See: technical-debt.md#DEBT-T005-001
```

**Operation 2: Create/Update technical-debt.md**

```markdown
# Technical Debt Report

**Sprint**: 006-quotes-technical-debt
**Generated**: 2025-09-30T10:35:00.000Z
**Data Source**: evidence/T005/technical-debt-data.json (script-generated)

---

## Critical Priority (Must Fix This Sprint)

### DEBT-T005-001: API Endpoint Missing: POST /api/quotes

[COPY EXACT CONTENT FROM technical-debt-data.json debtItems[0]]

**Sprint Task**: T031
**Inventory Reference**: DEBT-INV-2025-09-30-001
```

**Operation 3: Update debt-inventory.md**

```markdown
# Technical Debt Inventory

## Active Sprint Debt (Tracked in tasks.md)

### DEBT-INV-2025-09-30-001: POST /api/quotes Endpoint Missing
- **Sprint**: 006-quotes-technical-debt
- **Sprint Task**: T031
- **Status**: IN_SPRINT
- **Severity**: CRITICAL
- **Evidence**: evidence/T005/technical-debt-data.json
- **Created**: 2025-09-30T10:35:00.000Z
```

#### 2.3 Agent Instructions for Mechanical File Writing

Add to `/implement` command post-testing phase:

```markdown
## Step 6: Mechanical Technical Debt File Writing

**CRITICAL**: This is a MECHANICAL operation with ZERO interpretation allowed.

1. **Read Script-Generated Data**:
   ```javascript
   const debtData = JSON.parse(
     fs.readFileSync('evidence/[TASK_ID]/technical-debt-data.json', 'utf8')
   );
   ```

2. **For Each Debt Item**:

   **If routing.destination === "SPRINT_TASKS"**:
   - Find next available task number in tasks.md
   - Add new task using EXACT format from agentInstructions.taskFileUpdate
   - Copy ALL content from debtItem without modification
   - Link to evidence files exactly as listed

   **Always**:
   - Create/update technical-debt.md using agentInstructions.markdownFormat
   - Copy content from debtItem VERBATIM
   - Include ALL fields: title, description, classification, evidence, guidance
   - Maintain exact formatting

   **Always**:
   - Add entry to debt-inventory.md using inventoryCorrelationId
   - Include sprint task reference if routed to sprint
   - Mark status as IN_SPRINT or IN_INVENTORY
   - Link to technical-debt-data.json source

3. **Prohibited Actions**:
   - DO NOT modify severity, priority, or routing decisions
   - DO NOT summarize or rephrase descriptions
   - DO NOT skip evidence links
   - DO NOT mark debt as complete
   - DO NOT interpret or add your own analysis

4. **Verification**:
   ```javascript
   // After writing files, verify:
   - All debtItems from technical-debt-data.json are present
   - All sprint-routed items have tasks in tasks.md
   - All items have inventory correlation entries
   - Content matches source data exactly (no modifications)
   ```

5. **Report to User**:
   ```
   ✅ Technical debt files updated mechanically from script data
   📊 Summary:
   - 3 debt items processed
   - 2 added to sprint tasks (T031, T032)
   - 1 added to inventory only
   - 0 modifications to script decisions
   
   📁 Files updated:
   - tasks.md (added T031, T032)
   - technical-debt.md (created with 3 items)
   - debt-inventory.md (added 3 correlation entries)
   
   🔍 Verification: All content matches evidence/[TASK_ID]/technical-debt-data.json
   ```
```

#### 2.4 Validation Tool: Debt File Integrity Checker

**File**: `.specify/tools/validate-debt-integrity.js`

```javascript
/**
 * Validates that agent-written debt files match script-generated data
 * Detects any unauthorized modifications or interpretations
 */
class DebtIntegrityValidator {
  async validate(taskId) {
    // Load script-generated source of truth
    const sourceData = JSON.parse(
      fs.readFileSync(`evidence/${taskId}/technical-debt-data.json`, 'utf8')
    );
    
    // Load agent-written files
    const tasksContent = fs.readFileSync('tasks.md', 'utf8');
    const debtContent = fs.readFileSync('technical-debt.md', 'utf8');
    const inventoryContent = fs.readFileSync('debt-inventory.md', 'utf8');
    
    const violations = [];
    
    // Check each debt item
    for (const debtItem of sourceData.debtItems) {
      // Verify task presence if routed to sprint
      if (debtItem.routing.destination === 'SPRINT_TASKS') {
        if (!this.taskExists(tasksContent, debtItem.routing.sprintTaskId)) {
          violations.push({
            type: 'MISSING_SPRINT_TASK',
            debtId: debtItem.debtId,
            expectedTask: debtItem.routing.sprintTaskId
          });
        }
        
        // Verify task content matches
        if (!this.taskContentMatches(tasksContent, debtItem)) {
          violations.push({
            type: 'TASK_CONTENT_MISMATCH',
            debtId: debtItem.debtId,
            details: 'Task content modified from source data'
          });
        }
      }
      
      // Verify technical-debt.md presence
      if (!this.debtDocumented(debtContent, debtItem.debtId)) {
        violations.push({
          type: 'MISSING_DEBT_DOCUMENTATION',
          debtId: debtItem.debtId
        });
      }
      
      // Verify inventory correlation
      if (!this.inventoryCorrelated(inventoryContent, debtItem.routing.inventoryCorrelationId)) {
        violations.push({
          type: 'MISSING_INVENTORY_CORRELATION',
          debtId: debtItem.debtId,
          expectedCorrelationId: debtItem.routing.inventoryCorrelationId
        });
      }
      
      // Verify no severity/priority modifications
      if (!this.classificationsMatch(debtContent, debtItem)) {
        violations.push({
          type: 'CLASSIFICATION_MODIFIED',
          debtId: debtItem.debtId,
          details: 'Severity or priority was modified'
        });
      }
    }
    
    return {
      valid: violations.length === 0,
      violations,
      message: violations.length === 0 
        ? 'All debt files match script-generated data'
        : `Found ${violations.length} integrity violations`
    };
  }
}
```

**Result**: Technical debt is 100% script-controlled. Agent performs only mechanical file writing with validation.

---

## AMENDMENT 3: Task Status Authority

### Problem Statement

Who controls task completion status in tasks.md?

**Danger**: Agent could mark tasks as complete even when tests fail, bypassing testing entirely.

**Current Spec**: Script updates tasks.md, but doesn't prevent agent from overriding.

### Solution: Script-Owned Status with File Protection

**Principle**: Task status is OWNED by the script. Agent has READ-ONLY access to test results.

#### 3.1 Task Status Lock File

**File**: `.specify/state/task-status-lock.json`

Generated by script-execution-engine after every test run:

```json
{
  "lockVersion": "2.0.0",
  "generatedAt": "2025-09-30T10:40:00.000Z",
  "generatedBy": "CODOR Script Execution Engine v2.0",
  "testExecutionId": "exec-2025-09-30-1030",
  
  "taskStatuses": {
    "T004": {
      "status": "COMPLETE",
      "testsPassed": 15,
      "testsFailed": 0,
      "testsTotal": 15,
      "evidenceHash": "abc123...",
      "locked": true,
      "modificationProhibited": true
    },
    
    "T005": {
      "status": "FAILED",
      "testsPassed": 8,
      "testsFailed": 7,
      "testsTotal": 15,
      "evidenceHash": "def456...",
      "locked": true,
      "modificationProhibited": true,
      "technicalDebtCreated": ["DEBT-T005-001", "DEBT-T005-002"],
      "retestRequired": true
    },
    
    "T006": {
      "status": "PARTIAL",
      "testsPassed": 12,
      "testsFailed": 2,
      "testsTotal": 14,
      "evidenceHash": "ghi789...",
      "locked": true,
      "modificationProhibited": true,
      "acceptableFailures": true,
      "reason": "Expected TDD red phase failures"
    }
  },
  
  "lockSignature": {
    "algorithm": "SHA-256",
    "hash": "...",
    "tamperDetection": "enabled"
  },
  
  "agentPermissions": {
    "canReadStatus": true,
    "canModifyStatus": false,
    "canMarkComplete": false,
    "canMarkFailed": false,
    "canOverrideLock": false
  }
}
```

#### 3.2 Task Status Update Rules

**Script-Only Updates**:

```javascript
// script-execution-engine.js

class TaskStatusManager {
  async updateTaskStatus(taskId, testResults) {
    // Load current lock file
    const lockFile = this.loadLockFile();
    
    // Determine status based on OBJECTIVE test results
    const status = this.calculateStatus(testResults);
    
    // Update lock file
    lockFile.taskStatuses[taskId] = {
      status: status,
      testsPassed: testResults.passed,
      testsFailed: testResults.failed,
      testsTotal: testResults.total,
      evidenceHash: this.calculateEvidenceHash(taskId),
      locked: true,
      modificationProhibited: true,
      lastUpdated: new Date().toISOString()
    };
    
    // Add technical debt references if failed
    if (status === 'FAILED') {
      lockFile.taskStatuses[taskId].technicalDebtCreated = 
        await this.getDebtItemsForTask(taskId);
      lockFile.taskStatuses[taskId].retestRequired = true;
    }
    
    // Save lock file with signature
    await this.saveLockFile(lockFile);
    
    // Update tasks.md based on lock file
    await this.updateTasksMarkdown(taskId, lockFile.taskStatuses[taskId]);
  }

  calculateStatus(testResults) {
    // Objective calculation - no interpretation
    if (testResults.failed === 0) {
      return 'COMPLETE';
    }
    
    // Check if failures are acceptable (TDD red phase)
    if (this.areFailuresAcceptable(testResults)) {
      return 'PARTIAL';
    }
    
    return 'FAILED';
  }

  async updateTasksMarkdown(taskId, statusData) {
    const tasksContent = fs.readFileSync('tasks.md', 'utf8');
    
    // Find task checkbox
    const taskPattern = new RegExp(`^- \\[[ x]\\] \\*\\*${taskId}\\*\\*:`, 'gm');
    
    // Determine checkbox state
    const checkbox = statusData.status === 'COMPLETE' ? '[x]' : '[ ]';
    
    // Update checkbox and metadata
    const updatedContent = tasksContent.replace(
      taskPattern,
      match => {
        return match
          .replace(/^- \[[ x]\]/, `- ${checkbox}`)
          .replace(/\n  - Tests: .*$/m, `\n  - Tests: ${statusData.testsPassed}/${statusData.testsTotal} passed`)
          .replace(/\n  - Status: .*$/m, `\n  - Status: ${statusData.status} (LOCKED by script)`);
      }
    );
    
    fs.writeFileSync('tasks.md', updatedContent);
  }
}
```

#### 3.3 Agent Status Verification (Not Modification)

Agent can ONLY read status and act accordingly:

```markdown
## Agent Instructions for Task Status

**YOU CANNOT MODIFY TASK STATUS**

Task status is controlled by script-execution-engine and locked in:
- `.specify/state/task-status-lock.json`

### What You CAN Do:

1. **Read Task Status**:
   ```javascript
   const lockFile = JSON.parse(
     fs.readFileSync('.specify/state/task-status-lock.json', 'utf8')
   );
   
   const taskStatus = lockFile.taskStatuses['T005'];
   console.log(`T005 Status: ${taskStatus.status}`);
   console.log(`Tests: ${taskStatus.testsPassed}/${taskStatus.testsTotal} passed`);
   ```

2. **Act on Failed Tasks**:
   ```
   IF taskStatus.status === 'FAILED':
     - Read technical-debt.md for implementation requirements
     - Implement fixes as specified
     - Request retest: "Please rerun tests for T005"
     - DO NOT mark task complete yourself
   ```

3. **Report Status**:
   ```
   Report to user:
   "Task T005 FAILED: 8/15 tests passed
   Technical debt created: DEBT-T005-001, DEBT-T005-002
   Implementing fixes now..."
   ```

### What You CANNOT Do:

❌ Modify task-status-lock.json
❌ Mark checkboxes in tasks.md as [x] when tests failed
❌ Override script status decisions
❌ Skip retesting after fixes
❌ Claim task completion without passing tests
❌ Interpret test results differently than script

### Status Lock Enforcement:

The system will detect and reject any unauthorized status modifications:
- File integrity checking on task-status-lock.json
- Tamper detection via SHA-256 signatures
- Automatic reversal of unauthorized changes
- Constitutional violation report generated
```

#### 3.4 Status Lock Validation Tool

**File**: `.specify/tools/validate-status-lock.js`

```javascript
/**
 * Validates that task status hasn't been tampered with
 * Detects agent attempts to mark tasks complete without passing tests
 */
class StatusLockValidator {
  async validate() {
    // Load lock file
    const lockFile = JSON.parse(
      fs.readFileSync('.specify/state/task-status-lock.json', 'utf8')
    );
    
    // Verify lock file signature
    if (!this.verifySignature(lockFile)) {
      return {
        valid: false,
        violation: 'LOCK_FILE_TAMPERED',
        message: 'Lock file signature invalid - possible tampering detected'
      };
    }
    
    // Load tasks.md
    const tasksContent = fs.readFileSync('tasks.md', 'utf8');
    
    const violations = [];
    
    // Check each task status
    for (const [taskId, statusData] of Object.entries(lockFile.taskStatuses)) {
      // Find task checkbox in tasks.md
      const checkboxMatch = tasksContent.match(
        new RegExp(`^- \\[([x ])\\] \\*\\*${taskId}\\*\\*:`, 'm')
      );
      
      if (!checkboxMatch) continue;
      
      const checkboxState = checkboxMatch[1];
      const expectedState = statusData.status === 'COMPLETE' ? 'x' : ' ';
      
      // Check for unauthorized completion
      if (checkboxState === 'x' && statusData.status !== 'COMPLETE') {
        violations.push({
          type: 'UNAUTHORIZED_COMPLETION',
          taskId,
          actualStatus: statusData.status,
          tasksMarkdownState: 'complete',
          evidence: `Task ${taskId} marked [x] but status is ${statusData.status}`,
          testResults: `${statusData.testsPassed}/${statusData.testsTotal} tests passed`,
          action: 'Reverting checkbox to [ ]'
        });
        
        // Auto-revert unauthorized change
        this.revertUnauthorizedChange(taskId);
      }
      
      // Check for evidence tampering
      const currentEvidenceHash = this.calculateEvidenceHash(taskId);
      if (currentEvidenceHash !== statusData.evidenceHash) {
        violations.push({
          type: 'EVIDENCE_TAMPERING',
          taskId,
          message: 'Evidence files modified after test execution',
          action: 'Status invalidated - retest required'
        });
      }
    }
    
    // Generate violation report if any found
    if (violations.length > 0) {
      this.generateViolationReport(violations);
    }
    
    return {
      valid: violations.length === 0,
      violations,
      message: violations.length === 0 
        ? 'All task statuses valid and locked'
        : `Found ${violations.length} status violations - constitutional breach detected`
    };
  }

  revertUnauthorizedChange(taskId) {
    // Revert tasks.md checkbox to match lock file
    const lockFile = JSON.parse(
      fs.readFileSync('.specify/state/task-status-lock.json', 'utf8')
    );
    
    const statusData = lockFile.taskStatuses[taskId];
    const correctCheckbox = statusData.status === 'COMPLETE' ? '[x]' : '[ ]';
    
    const tasksContent = fs.readFileSync('tasks.md', 'utf8');
    const corrected = tasksContent.replace(
      new RegExp(`^- \\[[ x]\\] \\*\\*${taskId}\\*\\*:`, 'gm'),
      match => match.replace(/\[[ x]\]/, correctCheckbox)
    );
    
    fs.writeFileSync('tasks.md', corrected);
    
    console.log(`⚠️  REVERTED unauthorized completion of ${taskId}`);
    console.log(`    Status locked at: ${statusData.status}`);
    console.log(`    Tests: ${statusData.testsPassed}/${statusData.testsTotal} passed`);
  }

  generateViolationReport(violations) {
    const report = {
      timestamp: new Date().toISOString(),
      violationType: 'TASK_STATUS_TAMPERING',
      severity: 'CRITICAL',
      violations,
      constitutionalBreach: 'Passive Non-Compliance: Agent attempted to mark tasks complete without passing tests',
      evidencePreserved: true
    };
    
    fs.writeFileSync(
      `.specify/state/status-violations-${Date.now()}.json`,
      JSON.stringify(report, null, 2)
    );
    
    console.error('🚨 CONSTITUTIONAL VIOLATION DETECTED');
    console.error('   Task status tampering detected and reverted');
    console.error('   Violation report: .specify/state/status-violations-*.json');
  }
}

module.exports = StatusLockValidator;
```

#### 3.5 Integration with /implement Command

Modify implement-template.md to enforce status lock:

```markdown
## Phase 8: Status Lock Enforcement (AUTOMATIC)

**This runs automatically after Phase 7 (Testing Framework)**

1. **Validate Status Lock**:
   ```bash
   node .specify/tools/validate-status-lock.js
   ```

2. **If Violations Detected**:
   - Unauthorized task completions are REVERTED automatically
   - Agent receives constitutional violation report
   - Workflow HALTS until agent acknowledges
   - Agent must re-implement fixes and retest

3. **If No Violations**:
   - Status lock validated
   - Agent proceeds with failed task fixes
   - Agent REQUESTS retest (doesn't run it manually)

4. **Retest Workflow**:
   - Agent: "I've implemented fixes for T005. Please rerun tests."
   - System triggers: node .specify/tools/run-tests.js --task T005
   - Script updates status lock
   - Script updates tasks.md
   - Agent reads updated status
   - Repeat until status === 'COMPLETE'
```

**Result**: Task status is 100% script-controlled. Agent cannot mark tasks complete without passing tests. Tampering is detected and reverted automatically.

---

## Summary of Amendments

| Amendment | Problem | Solution | Authority |
|-----------|---------|----------|-----------|
| **1. Universal Test Support** | Can only handle Jest + MCP | Extensible executor system with ANY command type | Script |
| **2. Technical Debt Management** | Who generates debt? | Script generates complete structured data, agent writes files mechanically | Script decides, Agent writes |
| **3. Task Status Authority** | Agent could mark tasks complete | Script-owned status lock with tamper detection | Script only |

---

## Implementation Priority

1. **CRITICAL (Phase 1)**: Amendment 3 - Task Status Authority
   - Prevents agent from bypassing testing
   - Foundation for all other controls

2. **HIGH (Phase 2)**: Amendment 2 - Technical Debt Management
   - Ensures debt integrates with SDLC properly
   - Prevents debt manipulation

3. **MEDIUM (Phase 3)**: Amendment 1 - Universal Test Support
   - Expands capabilities but doesn't affect security
   - Can be implemented incrementally

---

## Validation Checklist

Before implementation begins, verify:

- [ ] Script-execution-engine owns task status updates
- [ ] Agent has read-only access to test results
- [ ] Status lock file prevents tampering
- [ ] Technical debt is 100% script-generated
- [ ] Agent performs only mechanical file writing
- [ ] Debt integrity validator detects modifications
- [ ] Executor system supports extensible action types
- [ ] Each executor has evidence collection
- [ ] All executors inherit from BaseExecutor

---

**END OF AMENDMENTS**
