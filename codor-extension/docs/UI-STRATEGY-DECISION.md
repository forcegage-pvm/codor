# CODOR UI Strategy - Spec Kit Workflow Display

**Date:** September 30, 2025  
**Status:** Design Decision - UI vs File Generation

---

## 🤔 The Question

> "Do we display specs in our UI? Or do we just wrap the /commands and still generate spec.md, plan.md files?"

---

## 📊 Three Approaches

### Option A: Pure UI (Database Only, No Files)

```
User Experience:

CODOR Panel:
┌─────────────────────────────────────┐
│ 📋 Features                         │
│                                     │
│ ├─ 001-core-features ✅            │
│ ├─ 002-ui-components 🔄            │
│ └─ ➕ New Feature                   │
└─────────────────────────────────────┘

User clicks "New Feature"
  ↓
CODOR shows form (webview)
┌─────────────────────────────────────┐
│ Feature Description:                │
│ [User authentication with JWT____]  │
│                                     │
│ [Generate Specification]            │
└─────────────────────────────────────┘
  ↓
CODOR calls Spec Kit scripts
  ↓
CODOR captures output
  ↓
CODOR stores in database (NO FILES!)
  ↓
CODOR shows rich UI:
┌─────────────────────────────────────┐
│ 📋 Specification                    │
│                                     │
│ Requirements:                       │
│ ☐ FR-001: User login               │
│ ☐ FR-002: JWT tokens               │
│                                     │
│ [Edit] [Generate Plan]              │
└─────────────────────────────────────┘

File System:
specs/
  (empty - no files created!)

Database:
.codor/
  tasks.db ← All data here
```

**Pros:**
- ✅ Rich interactive UI
- ✅ Perfect information control (no files for agent to find)
- ✅ Live editing
- ✅ Version history in database

**Cons:**
- ❌ No markdown files (can't view in GitHub, can't grep, can't use git diff)
- ❌ Not portable (database only)
- ❌ Loses Spec Kit's markdown-based workflow
- ❌ Agent can't reference spec.md

---

### Option B: Hybrid (Generate Files + Show in UI)

```
User Experience:

CODOR Panel:
┌─────────────────────────────────────┐
│ 📋 Features                         │
│                                     │
│ ├─ 001-core-features ✅            │
│ │   ├─ 📄 spec.md                  │
│ │   ├─ 📐 plan.md                  │
│ │   └─ 📊 tasks (database)         │
│ └─ ➕ New Feature                   │
└─────────────────────────────────────┘

User clicks "New Feature"
  ↓
CODOR shows form OR
User types: /specify User authentication
  ↓
Either way:
  1. CODOR calls Spec Kit scripts
  2. Scripts generate spec.md file ← FILE CREATED
  3. CODOR imports to database
  4. CODOR shows in UI
  ↓
┌─────────────────────────────────────┐
│ 📋 Specification (spec.md)          │
│                                     │
│ [View in Editor] [View in CODOR UI]│
└─────────────────────────────────────┘

User clicks "View in CODOR UI"
  ↓
Rich webview with spec content

User clicks "View in Editor"
  ↓
Opens specs/002-feature/spec.md

File System:
specs/
  002-user-auth/
    spec.md ← Generated by Spec Kit
    plan.md ← Generated by Spec Kit
    (NO tasks.md!) ← Intercepted by CODOR

Database:
.codor/
  tasks.db ← Tasks only
  (spec/plan in files, tasks in database)
```

**Pros:**
- ✅ Markdown files still exist (git-friendly, portable)
- ✅ Can view in GitHub, grep, diff
- ✅ Agent can reference spec.md and plan.md
- ✅ CODOR adds value with UI layer
- ✅ Best of both worlds

**Cons:**
- ⚠️ Dual storage (files + database for sync)
- ⚠️ Need to keep database in sync with files
- ⚠️ User might edit files directly (bypass CODOR)

---

### Option C: UI Wrappers for Commands (Minimal)

```
User Experience:

CODOR Panel:
┌─────────────────────────────────────┐
│ 📋 Spec Kit Commands                │
│                                     │
│ [/specify] New Feature              │
│ [/plan] Generate Plan               │
│ [/tasks] Generate Tasks             │
│                                     │
│ 📊 Task Queue (18 tasks)            │
│ 🔄 T001: Current task               │
└─────────────────────────────────────┘

User clicks "[/specify]"
  ↓
CODOR shows input dialog:
┌─────────────────────────────────────┐
│ Feature Description:                │
│ [User authentication____________]   │
│                                     │
│ [Run /specify Command]              │
└─────────────────────────────────────┘
  ↓
CODOR executes: /specify User authentication
(via GitHub Copilot chat API or direct script)
  ↓
Spec Kit generates: specs/002-feature/spec.md
  ↓
CODOR shows notification:
"✅ Specification created: specs/002-feature/spec.md"
  ↓
User clicks [/plan]
  ↓
CODOR executes: /plan
  ↓
Spec Kit generates: specs/002-feature/plan.md
  ↓
User clicks [/tasks]
  ↓
CODOR intercepts task generation
  ↓
Stores in database (NO tasks.md file)
  ↓
Shows task queue in UI

File System:
specs/
  002-user-auth/
    spec.md ← Generated
    plan.md ← Generated
    (NO tasks.md!)

Database:
.codor/
  tasks.db ← Tasks only
```

**Pros:**
- ✅ Minimal changes to Spec Kit workflow
- ✅ Files still generated (git-friendly)
- ✅ UI adds convenience (click vs type)
- ✅ Simple to implement
- ✅ Backward compatible

**Cons:**
- ⚠️ Less "integrated" feel
- ⚠️ User could just use /commands directly
- ⚠️ CODOR is just a launcher, not true UI layer

---

## 🎯 Recommendation: **Option B (Hybrid)** ⭐

### Why Hybrid is Best

1. **Keep Spec Kit's Strengths**
   - Markdown files are git-friendly
   - Can view/edit in any editor
   - Portable, greppable, diffable
   - Agent can reference spec.md

2. **Add CODOR's Strengths**
   - Rich UI for viewing
   - Task management in database
   - Perfect control over task distribution
   - Verification and evidence tracking

3. **Clear Separation**
   ```
   Spec Kit owns: spec.md, plan.md (design documents)
   CODOR owns: tasks (execution control)
   ```

### How It Works

```typescript
// Workflow with Hybrid Approach

class FeatureWorkflow {
  
  async createFeature(description: string) {
    // 1. Call Spec Kit /specify (generates spec.md)
    await specKit.specify(description);
    
    // 2. Import to database for rich UI
    const specContent = await fs.readFile('specs/XXX/spec.md', 'utf-8');
    await db.features.insert({
      specFile: 'specs/XXX/spec.md',
      specContent: specContent,  // Cache for UI
      status: 'planning'
    });
    
    // 3. Show in UI
    await showSpecificationView();
  }
  
  async generatePlan(featureId: string) {
    // 1. Call Spec Kit /plan (generates plan.md)
    await specKit.plan();
    
    // 2. Import to database
    const planContent = await fs.readFile('specs/XXX/plan.md', 'utf-8');
    await db.features.update(featureId, {
      planFile: 'specs/XXX/plan.md',
      planContent: planContent
    });
    
    // 3. Show in UI
    await showPlanView();
  }
  
  async generateTasks(featureId: string) {
    // 1. Call Spec Kit /tasks BUT intercept output
    const tasks = await specKit.tasksWithCodorMode();
    
    // 2. Store in database (NO tasks.md file!)
    await db.tasks.insertMany(tasks);
    
    // 3. Show task queue
    await showTaskQueueView();
  }
}
```

### File Structure

```
specs/
  002-user-authentication/
    spec.md          ← Spec Kit generates (markdown file)
    plan.md          ← Spec Kit generates (markdown file)
    contracts/       ← Design artifacts (files)
    data-model.md    ← Design artifacts (file)
    (NO tasks.md!)   ← CODOR intercepts

.codor/
  tasks.db         ← CODOR database
    - features table (metadata + cache of spec/plan content)
    - tasks table (execution control)
    - verification_results table
```

### UI Experience

```typescript
// CODOR Tree View

📋 CODOR
├─ 📁 Features
│  ├─ 001-core-features ✅
│  │  ├─ 📄 spec.md (click to open)
│  │  ├─ 📐 plan.md (click to open)
│  │  └─ ✅ Tasks: 15/15 verified
│  │
│  └─ 002-user-auth 🔄
│     ├─ 📄 spec.md (click to open)
│     ├─ 📐 plan.md (click to open)
│     └─ 📊 Tasks: 5/18 verified
│        ├─ ✅ T001: Setup
│        ├─ ✅ T002: Database
│        ├─ ✅ T003: User model
│        ├─ ✅ T004: Auth controller
│        ├─ 🔄 T005: JWT middleware (current)
│        └─ ⏳ T006-T018 (upcoming)
│
└─ ➕ New Feature (click to create)
```

**Clicking spec.md:**
- Opens markdown file in editor

**Right-click spec.md → "View in CODOR UI":**
- Shows rich webview with interactive requirements

**Clicking task:**
- Shows task details
- Can mark complete, verify, view evidence

---

## 🎨 UI Implementation

### Tree View Provider

```typescript
export class CodorTreeProvider implements vscode.TreeDataProvider<CodorItem> {
  
  async getChildren(element?: CodorItem): Promise<CodorItem[]> {
    if (!element) {
      // Root level
      return [
        new CodorItem('features', 'Features', '📁'),
        new CodorItem('new-feature', 'New Feature', '➕')
      ];
    }
    
    if (element.type === 'features') {
      // Show all features
      const features = await db.features.getAll();
      return features.map(f => new CodorItem('feature', f.title, '📋', f));
    }
    
    if (element.type === 'feature') {
      // Show feature artifacts
      const feature = element.data;
      const items = [];
      
      // Spec file (if exists)
      if (feature.specFile) {
        items.push(new CodorItem(
          'file',
          'spec.md',
          '📄',
          { path: feature.specFile }
        ));
      }
      
      // Plan file (if exists)
      if (feature.planFile) {
        items.push(new CodorItem(
          'file',
          'plan.md',
          '📐',
          { path: feature.planFile }
        ));
      }
      
      // Tasks (from database)
      const taskCount = await db.tasks.count({ featureId: feature.id });
      const completedCount = await db.tasks.count({
        featureId: feature.id,
        status: 'verified'
      });
      
      items.push(new CodorItem(
        'task-summary',
        `Tasks: ${completedCount}/${taskCount}`,
        '📊',
        { featureId: feature.id }
      ));
      
      return items;
    }
    
    if (element.type === 'task-summary') {
      // Show individual tasks
      const tasks = await db.tasks.getByFeature(element.data.featureId);
      return tasks.map(t => new CodorItem(
        'task',
        `${t.id}: ${t.title}`,
        this.getTaskIcon(t.status),
        t
      ));
    }
    
    return [];
  }
  
  getTreeItem(element: CodorItem): vscode.TreeItem {
    const item = new vscode.TreeItem(
      element.label,
      element.collapsibleState
    );
    
    item.iconPath = new vscode.ThemeIcon(element.icon);
    
    // Click handlers
    if (element.type === 'file') {
      // Open markdown file
      item.command = {
        command: 'vscode.open',
        arguments: [vscode.Uri.file(element.data.path)],
        title: 'Open File'
      };
    }
    
    if (element.type === 'task') {
      // Show task details
      item.command = {
        command: 'codor.showTaskDetails',
        arguments: [element.data],
        title: 'Show Task Details'
      };
    }
    
    if (element.type === 'new-feature') {
      item.command = {
        command: 'codor.newFeature',
        title: 'Create New Feature'
      };
    }
    
    // Context menu
    item.contextValue = element.type;
    
    return item;
  }
}
```

### Commands

```typescript
// New Feature Command
vscode.commands.registerCommand('codor.newFeature', async () => {
  const description = await vscode.window.showInputBox({
    prompt: 'Feature Description',
    placeHolder: 'e.g., User authentication with JWT tokens'
  });
  
  if (!description) return;
  
  // Call Spec Kit /specify
  await specKit.specify(description);
  
  // Import to database
  await importFeatureToDatabase();
  
  // Refresh UI
  treeProvider.refresh();
});

// View in CODOR UI (context menu)
vscode.commands.registerCommand('codor.viewInUI', async (item) => {
  if (item.type === 'file' && item.data.path.endsWith('spec.md')) {
    await showSpecificationWebview(item.data.path);
  }
});

// Generate Plan
vscode.commands.registerCommand('codor.generatePlan', async (feature) => {
  await specKit.plan();
  await importPlanToDatabase(feature.id);
  treeProvider.refresh();
});

// Generate Tasks
vscode.commands.registerCommand('codor.generateTasks', async (feature) => {
  const tasks = await specKit.tasksWithCodorMode();
  await db.tasks.insertMany(tasks);
  treeProvider.refresh();
});
```

---

## 🔄 Sync Strategy

### Keep Database in Sync with Files

```typescript
// File watcher for spec.md and plan.md changes
const watcher = vscode.workspace.createFileSystemWatcher(
  'specs/**/+(spec|plan).md'
);

watcher.onDidChange(async (uri) => {
  // User edited spec.md or plan.md directly
  // Re-import to database to keep cache fresh
  
  const content = await fs.readFile(uri.fsPath, 'utf-8');
  const featureId = extractFeatureIdFromPath(uri.fsPath);
  
  if (uri.fsPath.endsWith('spec.md')) {
    await db.features.update(featureId, {
      specContent: content,
      specUpdatedAt: new Date()
    });
  } else if (uri.fsPath.endsWith('plan.md')) {
    await db.features.update(featureId, {
      planContent: content,
      planUpdatedAt: new Date()
    });
  }
  
  // Refresh UI
  treeProvider.refresh();
});
```

---

## 📝 Summary of Hybrid Approach

### What Gets Generated as Files (Spec Kit)

```
specs/002-user-auth/
  spec.md         ✅ File (Spec Kit generates)
  plan.md         ✅ File (Spec Kit generates)
  contracts/      ✅ Files (design artifacts)
  data-model.md   ✅ File (design artifacts)
```

### What Lives in Database (CODOR)

```
.codor/tasks.db
  features:
    - id
    - specFile (path reference)
    - planFile (path reference)
    - specContent (cached for UI)
    - planContent (cached for UI)
  
  tasks:
    - id (T001, T002...)
    - featureId
    - title, description, filePath
    - status, verificationResults
```

### User Interaction

```
Viewing spec/plan:
  - Click in tree → opens markdown file ✅
  - Right-click → "View in CODOR UI" → webview ✅
  - Can edit file directly ✅
  - CODOR syncs changes to database ✅

Working with tasks:
  - Only in CODOR UI (no tasks.md file) ✅
  - Agent gets tasks from CODOR ✅
  - Verification managed by CODOR ✅
```

### Benefits

1. ✅ **Git-friendly** - spec.md and plan.md are in git
2. ✅ **Agent-friendly** - Can reference design documents
3. ✅ **Developer-friendly** - Can view/edit in any editor
4. ✅ **CODOR control** - Tasks in database, perfect enforcement
5. ✅ **Best of both** - Spec Kit workflow + CODOR management

---

## 🎯 Final Recommendation

**Go with Option B (Hybrid):**

1. Let Spec Kit generate spec.md and plan.md (markdown files)
2. CODOR imports content to database (for UI caching)
3. CODOR intercepts task generation (stores in database only)
4. CODOR provides rich UI layer on top
5. User can use either UI or files as they prefer

**This gives flexibility while maintaining control where it matters (tasks).** ✅

Does this approach make sense? Should we proceed with Hybrid? 🚀
